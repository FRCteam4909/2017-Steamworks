// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4909.STEAMWORKS;

import org.usfirst.frc4909.STEAMWORKS.PID.PIDController;

import edu.wpi.first.wpilibj.AnalogPotentiometer;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.PIDSourceType;
import edu.wpi.first.wpilibj.PowerDistributionPanel;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.SerialPort;

import edu.wpi.first.wpilibj.livewindow.LiveWindow;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import com.kauailabs.navx.frc.AHRS;

/**
 * The RobotMap is a mapping from the ports sensors and actuators are wired into
 * to a variable name. This provides flexibility changing wiring, makes checking
 * the wiring easier and significantly reduces the number of magic numbers
 * floating around.
 */
public class RobotMap {
    // Drivetrain
    public static RobotDrive drivetrainRobotDrive;
    
    public static AHRS navx;
    public static Encoder drivetrainLeftEncoder;
    public static Encoder drivetrainRightEncoder;
    
    public static SpeedController drivetrainLeftFrontDriveMotorController;
    public static SpeedController drivetrainLeftBackDriveMotorController;
    public static SpeedController drivetrainRightBackDriveMotorController;
    public static SpeedController drivetrainRightFrontDriveMotorController;

    // Climber
    public static SpeedController climberClimberMotorController;
    public static Encoder climberClimberEncoder;
    public static DigitalInput climberSwitch;
    
    // Intake
    public static AnalogPotentiometer intakePivotPot;
    public static SpeedController intakeIntakeMotor;
    public static SpeedController intakePivotMotor;
    
    // Feeder
    public static SpeedController feederFeederMotor;
    
    // Shooter
    public static SpeedController shooterShooterMotorController;
    public static Encoder shooterShooterEncoder;
    
    public static PIDController shooterPID;
    public static double shooterP = 0.00015;
    public static double shooterI = 0.00000;
    public static double shooterD = 0.00000;
    public static double shooterF = 0.00050;
    
    // Loader
    public static SpeedController loaderMotor;
    public static AnalogPotentiometer loaderPivotPot;
    
    // Power Distribution Panel
	public static PowerDistributionPanel PDP;
    
    public static void init() {
        // Drivetrain
        drivetrainLeftFrontDriveMotorController = new Talon(0);
        drivetrainLeftBackDriveMotorController = new Talon(1);
        drivetrainRightBackDriveMotorController = new Talon(3);
        drivetrainRightFrontDriveMotorController = new Talon(2);
        
        navx = new AHRS(SerialPort.Port.kMXP);
        
        drivetrainLeftEncoder = new Encoder(0, 1, true, EncodingType.k4X);
        drivetrainRightEncoder = new Encoder(2, 3, false, EncodingType.k4X);
        
        LiveWindow.addActuator("Drivetrain", "LeftFrontDriveMotorController", (Talon) drivetrainLeftFrontDriveMotorController);
        LiveWindow.addActuator("Drivetrain", "LeftBackDriveMotorController", (Talon) drivetrainLeftBackDriveMotorController);
        LiveWindow.addActuator("Drivetrain", "RightBackDriveMotorController", (Talon) drivetrainRightBackDriveMotorController);
        LiveWindow.addActuator("Drivetrain", "RightFrontDriveMotorController", (Talon) drivetrainRightFrontDriveMotorController);
        
        LiveWindow.addSensor("Drivetrain", "LeftEncoder", drivetrainLeftEncoder);
        LiveWindow.addSensor("Drivetrain", "RightEncoder", drivetrainRightEncoder);
        
        drivetrainRobotDrive = new RobotDrive(drivetrainLeftFrontDriveMotorController, drivetrainLeftBackDriveMotorController,
              drivetrainRightFrontDriveMotorController, drivetrainRightBackDriveMotorController);
        
        drivetrainRobotDrive.setSafetyEnabled(true);
        drivetrainRobotDrive.setExpiration(0.1);
        drivetrainRobotDrive.setSensitivity(0.5);
        drivetrainRobotDrive.setMaxOutput(1.0);
        
        drivetrainRobotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
        drivetrainRobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        drivetrainRobotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        drivetrainRobotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
        
        drivetrainLeftEncoder.setDistancePerPulse(1.0);
        drivetrainRightEncoder.setDistancePerPulse(1.0);
        
        drivetrainLeftEncoder.setPIDSourceType(PIDSourceType.kRate);
        drivetrainRightEncoder.setPIDSourceType(PIDSourceType.kRate);
        
        // Climber
        climberClimberMotorController = new Talon(5);
        climberClimberEncoder = new Encoder(4, 5, false, EncodingType.k4X);
        climberSwitch= new DigitalInput(6);   
        
        LiveWindow.addActuator("Climber", "ClimberMotorController", (Talon) climberClimberMotorController);
        LiveWindow.addSensor("Climber", "ClimberEncoder", climberClimberEncoder);
        
        climberClimberEncoder.setDistancePerPulse(1.0);
        climberClimberEncoder.setPIDSourceType(PIDSourceType.kRate);
        
        // Intake
        intakePivotPot = new AnalogPotentiometer(0, 1.0, 0.0);
        intakeIntakeMotor = new Talon(7);
        intakePivotMotor= new Talon(8);
        
        LiveWindow.addSensor("Intake", "PivotPot", intakePivotPot);
        LiveWindow.addActuator("Intake", "IntakeMotor", (Talon) intakeIntakeMotor);
        LiveWindow.addActuator("Intake", "IntakePivotMotorController", (Talon) intakePivotMotor);
        
        // Feeder
        feederFeederMotor = new Talon(6);
        LiveWindow.addActuator("Feeder", "FeederMotor", (Talon) feederFeederMotor);
        
        // Shooter
        shooterShooterMotorController = new Talon(4);
        shooterShooterEncoder = new Encoder(6, 7, true, EncodingType.k4X);
        
        LiveWindow.addActuator("Shooter", "ShooterMotorController", (Talon) shooterShooterMotorController);
        LiveWindow.addSensor("Shooter", "ShooterEncoder", shooterShooterEncoder);
        
        shooterShooterMotorController.setInverted(true);
        
        shooterShooterEncoder.setDistancePerPulse(1.0);
        shooterShooterEncoder.setPIDSourceType(PIDSourceType.kRate);
        shooterShooterEncoder.setDistancePerPulse(1.0/(2048.0/48.0));
        
    	SmartDashboard.putNumber("P", shooterP);
    	SmartDashboard.putNumber("I", shooterI);
    	SmartDashboard.putNumber("D", shooterD);
    	SmartDashboard.putNumber("F", shooterF);

    	shooterPID = new PIDController(shooterP, shooterI, shooterD,1);
    
        // Loader
    	loaderMotor = new Talon(9);
    	loaderPivotPot = new AnalogPotentiometer(1, 3600, 0.0);
<<<<<<< HEAD
        
        LiveWindow.addActuator("Loader", "LoaderMotor", (Talon) loaderMotor);
        LiveWindow.addSensor("Loader", "PivotPot", loaderPivotPot);
=======
       LiveWindow.addSensor("Loader", "PivotPot", loaderPivotPot);
       
       intakePivotMotor= new Talon(8);
       LiveWindow.addActuator("Intake", "IntakePivotMotorController", (Talon) intakePivotMotor);
       
       climberSwitch= new DigitalInput(8);
       
>>>>>>> master
       
        // PDP
    	PDP = new PowerDistributionPanel();
    }
}
